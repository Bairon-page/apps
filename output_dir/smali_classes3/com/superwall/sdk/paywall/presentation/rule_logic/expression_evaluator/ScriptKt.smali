.class public final Lcom/superwall/sdk/paywall/presentation/rule_logic/expression_evaluator/ScriptKt;
.super Ljava/lang/Object;
.source "SourceFile"


# annotations
.annotation runtime Lkotlin/Metadata;
    d1 = {
        "\u0000\n\n\u0000\n\u0002\u0010\u000e\n\u0002\u0008\u0003\"\u0014\u0010\u0000\u001a\u00020\u0001X\u0086D\u00a2\u0006\u0008\n\u0000\u001a\u0004\u0008\u0002\u0010\u0003\u00a8\u0006\u0004"
    }
    d2 = {
        "SDKJS",
        "",
        "getSDKJS",
        "()Ljava/lang/String;",
        "superwall_release"
    }
    k = 0x2
    mv = {
        0x1,
        0x9,
        0x0
    }
    xi = 0x30
.end annotation


# static fields
.field private static final SDKJS:Ljava/lang/String;


# direct methods
.method static constructor <clinit>()V
    .locals 2

    new-instance v0, Ljava/lang/StringBuilder;

    const v1, 0x14f48

    invoke-direct {v0, v1}, Ljava/lang/StringBuilder;-><init>(I)V

    const-string v1, "\n/*! For license information please see main.js.LICENSE.txt */\nvar SuperwallSDKJS\n;(() => {\n  \"use strict\"\n  var __webpack_modules__ = {\n      276: (e, t, r) => {\n        r.d(t, { Jx: () => m })\n        const s = \"function\" == typeof atob,\n          n = \"function\" == typeof Buffer,\n          i = \"function\" == typeof TextDecoder ? new TextDecoder() : void 0,\n          o = ((e) => {\n            let t = {}\n            return e.forEach((e, r) => (t[e] = r)), t\n          })(\n            (\"function\" == typeof TextEncoder && new TextEncoder(),\n            [...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"])\n          ),\n          a = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/,\n          l = String.fromCharCode.bind(String),\n          h =\n            \"function\" == typeof Uint8Array.from\n              ? Uint8Array.from.bind(Uint8Array)\n              : (e, t = (e) => e) => new Uint8Array(Array.prototype.slice.call(e, 0).map(t)),\n          c = (e) => e.replace(/[^A-Za-z0-9\\+\\/]/g, \"\"),\n          u = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g,\n          p = (e) => {\n            switch (e.length) {\n              case 4:\n                var t =\n                  (((7 & e.charCodeAt(0)) << 18) |\n                    ((63 & e.charCodeAt(1)) << 12) |\n                    ((63 & e.charCodeAt(2)) << 6) |\n                    (63 & e.charCodeAt(3))) -\n                  65536\n                return l(55296 + (t >>> 10)) + l(56320 + (1023 & t))\n              case 3:\n                return l(\n                  ((15 & e.charCodeAt(0)) << 12) |\n                    ((63 & e.charCodeAt(1)) << 6) |\n                    (63 & e.charCodeAt(2))\n                )\n              default:\n                return l(((31 & e.charCodeAt(0)) << 6) | (63 & e.charCodeAt(1)))\n            }\n          },\n          d = s\n            ? (e) => atob(c(e))\n            : n\n            ? (e) => Buffer.from(e, \"base64\").toString(\"binary\")\n            : (e) => {\n                if (((e = e.replace(/\\s+/g, \"\")), !a.test(e)))\n                  throw new TypeError(\"malformed base64.\")\n                e += \"==\".slice(2 - (3 & e.length))\n                let t,\n                  r,\n                  s,\n                  n = \"\"\n                for (let i = 0; i < e.length; )\n                  (t =\n                    (o[e.charAt(i++)] << 18) |\n                    (o[e.charAt(i++)] << 12) |\n                    ((r = o[e.charAt(i++)]) << 6) |\n                    (s = o[e.charAt(i++)])),\n                    (n +=\n                      64 === r\n                        ? l((t >> 16) & 255)\n                        : 64 === s\n                        ? l((t >> 16) & 255, (t >> 8) & 255)\n                        : l((t >> 16) & 255, (t >> 8) & 255, 255 & t))\n                return n\n              },\n          f = n ? (e) => h(Buffer.from(e, \"base64\")) : (e) => h(d(e), (e) => e.charCodeAt(0)),\n          g = n\n            ? (e) => Buffer.from(e, \"base64\").toString(\"utf8\")\n            : i\n            ? (e) => i.decode(f(e))\n            : (e) => d(e).replace(u, p),\n          m = (e) => g(c(e.replace(/[-_]/g, (e) => (\"-\" == e ? \"+\" : \"/\"))))\n      },\n      620: (e, t, r) => {\n        r.d(t, { Kj: () => Ct })\n        class s {\n          valueOf() {}\n          liquidMethodMissing(e) {}\n        }\n        var n = function () {\n          return (n =\n            Object.assign ||\n            function (e) {\n              for (var t, r = 1, s = arguments.length; r < s; r++)\n                for (var n in (t = arguments[r]))\n                  Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])\n              return e\n            }).apply(this, arguments)\n        }\n        const i = Object.prototype.toString,\n          o = String.prototype.toLowerCase\n        function a(e) {\n          return \"[object String]\" === i.call(e)\n        }\n        function l(e) {\n          return \"function\" == typeof e\n        }\n        function h(e) {\n          return d((e = c(e))) ? \"\" : String(e)\n        }\n        function c(e) {\n          return e instanceof s ? e.valueOf() : e\n        }\n        function u(e) {\n          return \"number\" == typeof e\n        }\n        function p(e) {\n          return e && l(e.toLiquid) ? p(e.toLiquid()) : e\n        }\n        function d(e) {\n          return null == e\n        }\n        function f(e) {\n          return \"[object Array]\" === i.call(e)\n        }\n        function g(e, t) {\n          e = e || {}\n          for (const r in e) if (e.hasOwnProperty(r) && !1 === t(e[r], r, e)) break\n          return e\n        }\n        function m(e) {\n          return e[e.length - 1]\n        }\n        function w(e) {\n          const t = typeof e\n          return null !== e && (\"object\" === t || \"function\" === t)\n        }\n        function T(e, t, r = 1) {\n          const s = []\n          for (let n = e; n < t; n += r) s.push(n)\n          return s\n        }\n        function y(e, t, r = \" \") {\n          return b(e, t, r, (e, t) => t + e)\n        }\n        function b(e, t, r, s) {\n          let n = t - (e = String(e)).length\n          for (; n-- > 0; ) e = s(e, r)\n          return e\n        }\n        function k(e) {\n          return e\n        }\n        function v(e) {\n          return e.replace(/(\\w?)([A-Z])/g, (e, t, r) => (t ? t + \"_\" : \"\") + r.toLowerCase())\n        }\n        function _(e, t) {\n          return null == e && null == t\n            ? 0\n            : null == e\n            ? 1\n            : null == t || (e = o.call(e)) < (t = o.call(t))\n            ? -1\n            : e > t\n            ? 1\n            : 0\n        }\n        class x {\n          constructor(e, t, r, s) {\n            ;(this.key = e), (this.value = t), (this.next = r), (this.prev = s)\n          }\n        }\n        class O {\n          constructor(e, t = 0) {\n            ;(this.limit = e),\n              (this.size = t),\n              (this.cache = {}),\n              (this.head = new x(\"HEAD\", null, null, null)),\n              (this.tail = new x(\"TAIL\", null, null, null)),\n              (this.head.next = this.tail),\n              (this.tail.prev = this.head)\n          }\n          write(e, t) {\n            if (this.cache[e]) this.cache[e].value = t\n            else {\n              const r = new x(e, t, this.head.next, this.head)\n              ;(this.head.next.prev = r),\n                (this.head.next = r),\n                (this.cache[e] = r),\n                this.size++,\n                this.ensureLimit()\n            }\n          }\n          read(e) {\n            if (!this.cache[e]) return\n            const { value: t } = this.cache[e]\n            return this.remove(e), this.write(e, t), t\n          }\n          remove(e) {\n            const t = this.cache[e]\n            ;(t.prev.next = t.next), (t.next.prev = t.prev), delete this.cache[e], this.size--\n          }\n          clear() {\n            ;(this.head.next = this.tail),\n              (this.tail.prev = this.head),\n              (this.size = 0),\n              (this.cache = {})\n          }\n          ensureLimit() {\n            this.size > this.limit && this.remove(this.tail.prev.key)\n          }\n        }\n        var S = Object.freeze({\n          resolve: function (e, t, r) {\n            return (\n              e.length && \"/\" !== m(e) && (e += \"/\"),\n              (function (e, t) {\n                const r = document.createElement(\"base\")\n                r.href = e\n                const s = document.getElementsByTagName(\"head\")[0]\n                s.insertBefore(r, s.firstChild)\n                const n = document.createElement(\"a\")\n                n.href = t\n                const i = n.href\n                return s.removeChild(r), i\n              })(e, t).replace(/^(\\w+:\\/\\/[^/]+)(\\/[^?]+)/, (e, t, s) => {\n                const n = s.split(\"/\").pop()\n                return /\\.\\w+$/.test(n) ? e : t + s + r\n              })\n            )\n          },\n          readFile: async function (e) {\n            return new Promise((t, r) => {\n              const s = new XMLHttpRequest()\n              ;(s.onload = () => {\n                s.status >= 200 && s.status < 300 ? t(s.responseText) : r(new Error(s.statusText))\n              }),\n                (s.onerror = () => {\n                  r(new Error(\"An error occurred whilst receiving the response.\"))\n                }),\n                s.open(\"GET\", e),\n                s.send()\n            })\n          },\n          readFileSync: function (e) {\n            const t = new XMLHttpRequest()\n            if ((t.open(\"GET\", e, !1), t.send(), t.status < 200 || t.status >= 300))\n              throw new Error(t.statusText)\n            return t.responseText\n          },\n          exists: async function (e) {\n            return !0\n          },\n          existsSync: function (e) {\n            return !0\n          },\n        })\n        function q(e) {\n          return e && l(e.equals)\n        }\n        function E(e, t) {\n          return !R(e, t)\n        }\n        function R(e, t) {\n          return t.opts.jsTruthy ? !e : !1 === e || null == e\n        }\n        const A = {\n            \"==\": (e, t) => (q(e) ? e.equals(t) : q(t) ? t.equals(e) : e === t),\n            \"!=\": (e, t) => (q(e) ? !e.equals(t) : q(t) ? !t.equals(e) : e !== t),\n            \">\": (e, t) => (q(e) ? e.gt(t) : q(t) ? t.lt(e) : e > t),\n            \"<\": (e, t) => (q(e) ? e.lt(t) : q(t) ? t.gt(e) : e < t),\n            \">=\": (e, t) => (q(e) ? e.geq(t) : q(t) ? t.leq(e) : e >= t),\n            \"<=\": (e, t) => (q(e) ? e.leq(t) : q(t) ? t.geq(e) : e <= t),\n            contains: (e, t) => !(!e || !l(e.indexOf)) && e.indexOf(t) > -1,\n            and: (e, t, r) => E(e, r) && E(t, r),\n            or: (e, t, r) => E(e, r) || E(t, r),\n          },\n          D = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 4, 4, 4, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 20, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 64, 0, 65, 0, 0, 33, 33, 33, 33, 33, 33, 33,\n            33, 33, 33, 0, 0, 2, 2, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,\n          ]\n        function F(e) {\n          const t = {}\n          for (const [r, s] of Object.entries(e)) {\n            let e = t\n            for (let t = 0; t < r.length; t++) {\n              const s = r[t]\n              ;(e[s] = e[s] || {}),\n                t === r.length - 1 && 1 & D[r.charCodeAt(t)] && (e[s].needBoundary = !0),\n                (e = e[s])\n            }\n            ;(e.handler = s), (e.end = !0)\n          }\n          return t\n        }\n        D[160] =\n          D[5760] =\n          D[6158] =\n          D[8192] =\n          D[8193] =\n          D[8194] =\n          D[8195] =\n          D[8196] =\n          D[8197] =\n          D[8198] =\n          D[8199] =\n          D[8200] =\n          D[8201] =\n          D[8202] =\n          D[8232] =\n          D[8233] =\n          D[8239] =\n          D[8287] =\n          D[12288] =\n            4\n        const M = {\n          root: [\".\"],\n          cache: void 0,\n          extname: \"\",\n          fs: S,\n          dynamicPartials: !0,\n          jsTruthy: !1,\n          trimTagRight: !1,\n          trimTagLeft: !1,\n          trimOutputRight: !1,\n          trimOutputLeft: !1,\n          greedy: !0,\n          tagDelimiterLeft: \"{%\",\n          tagDelimiterRight: \"%}\",\n          outputDelimiterLeft: \"{{\",\n          outputDelimiterRight: \"}}\",\n          preserveTimezones: !1,\n          strictFilters: !1,\n          strictVariables: !1,\n          lenientIf: !1,\n          globals: {},\n          keepOutputType: !1,\n          operators: A,\n          operatorsTrie: F(A),\n        }\n        function L(e) {\n          if (\n            ((e = e || {}).hasOwnProperty(\"root\") && (e.root = P(e.root)),\n            e.hasOwnProperty(\"cache\"))\n          ) {\n            let t\n            ;(t =\n              \"number\" == typeof e.cache\n                ? e.cache > 0\n                  ? new O(e.cache)\n                  : void 0\n                : \"object\" == typeof e.cache\n                ? e.cache\n                : e.cache\n                ? new O(1024)\n                : void 0),\n              (e.cache = t)\n          }\n          return e.hasOwnProperty(\"operators\") && (e.operatorsTrie = F(e.operators)), e\n        }\n        function P(e) {\n          return f(e) ? e : a(e) ? [e] : []\n        }\n        class N extends Error {\n          constructor(e, t) {\n            super(e.message), (this.originalError = e), (this.token = t), (this.context = \"\")\n          }\n          update() {\n            const e = this.originalError\n            ;(this.context = (function (e) {\n              const [t] = e.getPosition(),\n                r = e.input.split(\"\\n\"),\n                s = Math.max(t - 2, 1),\n                n = Math.min(t + 3, r.length)\n              return T(s, n + 1)\n                .map(\n                  (e) => `${e === t ? \">> \" : \"   \"}${y(String(e), String(n).length)}| ${r[e - 1]}`\n                )\n                .join(\"\\n\")\n            })(this.token)),\n              (this.message = (function (e, t) {\n                t.file && (e += `, file:${t.file}`)\n                const [r, s] = t.getPosition()\n                return e + `, line:${r}, col:${s}`\n              })(e.message, this.token)),\n              (this.stack =\n                this.message + \"\\n\" + this.context + \"\\n\" + this.stack + \"\\nFrom \" + e.stack)\n          }\n        }\n        class $ extends N {\n          constructor(e, t) {\n            super(new Error(e), t), (this.name = \"TokenizationError\"), super.update()\n          }\n        }\n        class C extends N {\n          constructor(e, t) {\n            super(e, t), (this.name = \"ParseError\"), (this.message = e.message), super.update()\n          }\n        }\n        class I extends N {\n          constructor(e, t) {\n            super(e, t.token),\n              (this.name = \"RenderError\"),\n              (this.message = e.message),\n              super.update()\n          }\n          static is(e) {\n            return \"RenderError\" === e.name\n          }\n        }\n        class B extends N {\n          constructor(e, t) {\n            super(e, t),\n              (this.name = \"UndefinedVariableError\"),\n              (this.message = e.message),\n              super.update()\n          }\n        }\n        class j extends Error {\n          constructor(e) {\n            super(`undefined variable: ${e}`),\n              (this.name = \"InternalUndefinedVariableError\"),\n              (this.variableName = e)\n          }\n        }\n        class V extends Error {\n          constructor(e) {\n            super(e), (this.name = \"AssertionError\"), (this.message = e + \"\")\n          }\n        }\n        class z {\n          constructor(e = {}, t = M, r = !1) {\n            ;(this.scopes = [{}]),\n              (this.registers = {}),\n              (this.sync = r),\n              (this.opts = t),\n              (this.globals = t.globals),\n              (this.environments = e)\n          }\n          getRegister(e, t = {}) {\n            return (this.registers[e] = this.registers[e] || t)\n          }\n          setRegister(e, t) {\n            return (this.registers[e] = t)\n          }\n          saveRegister(...e) {\n            return e.map((e) => [e, this.getRegister(e)])\n          }\n          restoreRegister(e) {\n            return e.forEach(([e, t]) => this.setRegister(e, t))\n          }\n          getAll() {\n            return [this.globals, this.environments, ...this.scopes].reduce((e, t) => n(e, t), {})\n          }\n          get(e) {\n            const t = this.findScope(e[0])\n            return this.getFromScope(t, e)\n          }\n          getFromScope(e, t) {\n            return (\n              \"string\" == typeof t && (t = t.split(\".\")),\n              t.reduce((e, t) => {\n                if (\n                  ((n = t),\n                  (e = d((r = e))\n                    ? r\n                    : l((r = p(r))[n])\n                    ? r[n]()\n                    : r instanceof s\n                    ? r.hasOwnProperty(n)\n                      ? r[n]\n                      : r.liquidMethodMissing(n)\n                    : \"size\" === n\n                    ? (function (e) {\n                        return f(e) || a(e) ? e.length : e.size\n                      })(r)\n                    : \"first\" === n\n                    ? (function (e) {\n                        return f(e) ? e[0] : e.first\n                      })(r)\n                    : \"last\" === n\n                    ? (function (e) {\n                        return f(e) ? e[e.length - 1] : e.last\n                      })(r)\n                    : r[n]),\n                  d(e) && this.opts.strictVariables)\n                )\n                  throw new j(t)\n                var r, n\n                return e\n              }, e)\n            )\n          }\n          push(e) {\n            return this.scopes.push(e)\n          }\n          pop() {\n            return this.scopes.pop()\n          }\n          bottom() {\n            return this.scopes[0]\n          }\n          findScope(e) {\n            for (let t = this.scopes.length - 1; t >= 0; t--) {\n              const r = this.scopes[t]\n              if (e in r) return r\n            }\n            return e in this.environments ? this.environments : this.globals\n          }\n        }\n        var U\n        function H(e) {\n          return Q(e) === U.Operator\n        }\n        function J(e) {\n          return Q(e) === U.HTML\n        }\n        function W(e) {\n          return Q(e) === U.Tag\n        }\n        function K(e) {\n          return Q(e) === U.Quoted\n        }\n        function Q(e) {\n          return e ? e.kind : -1\n        }\n        function Z(e, t) {\n          if (!e || !J(e)) return\n          const r = t ? 4 : 16\n          for (; D[e.input.charCodeAt(e.end - 1 - e.trimRight)] & r; ) e.trimRight++\n        }\n        function Y(e, t) {\n          if (!e || !J(e)) return\n          const r = t ? 4 : 16\n          for (; D[e.input.charCodeAt(e.begin + e.trimLeft)] & r; ) e.trimLeft++\n          \"\\n\" === e.input.charAt(e.begin + e.trimLeft) && e.trimLeft++\n        }\n        !(function (e) {\n          ;(e[(e.Number = 1)] = \"Number\"),\n            (e[(e.Literal = 2)] = \"Literal\"),\n            (e[(e.Tag = 4)] = \"Tag\"),\n            (e[(e.Output = 8)] = \"Output\"),\n            (e[(e.HTML = 16)] = \"HTML\"),\n            (e[(e.Filter = 32)] = \"Filter\"),\n            (e[(e.Hash = 64)] = \"Hash\"),\n            (e[(e.PropertyAccess = 128)] = \"PropertyAccess\"),\n            (e[(e.Word = 256)] = \"Word\"),\n            (e[(e.Range = 512)] = \"Range\"),\n            (e[(e.Quoted = 1024)] = \"Quoted\"),\n            (e[(e.Operator = 2048)] = \"Operator\"),\n            (e[(e.Delimited = 12)] = \"Delimited\")\n        })(U || (U = {}))\n        class X {\n          constructor(e, t, r, s, n) {\n            ;(this.kind = e), (this.input = t), (this.begin = r), (this.end = s), (this.file = n)\n          }\n          getText() {\n            return this.input.slice(this.begin, this.end)\n          }\n          getPosition() {\n            let [e, t] = [1, 1]\n            for (let r = 0; r < this.begin; r++) \"\\n\" === this.input[r] ? (e++, (t = 1)) : t++\n            return [e, t]\n          }\n          size() {\n            return this.end - this.begin\n          }\n        }\n        class G extends X {\n          constructor(e, t) {\n            super(U.Number, e.input, e.begin, t ? t.end : e.end, e.file),\n              (this.whole = e),\n              (this.decimal = t)\n          }\n        }\n        class ee extends X {\n          constructor(e, t, r, s) {\n            super(U.Word, e, t, r, s),\n              (this.input = e),\n              (this.begin = t),\n              (this.end = r),\n              (this.file = s),\n              (this.content = this.getText())\n          }\n          isNumber(e = !1) {\n            for (\n              let t = e && 64 & D[this.input.charCodeAt(this.begin)] ? this.begin + 1 : this.begin;\n              t < this.end;\n              t++\n            )\n              if (!(32 & D[this.input.charCodeAt(t)])) return !1\n            return !0\n          }\n        }\n        class te extends s {\n          equals(e) {\n            return !(\n              e instanceof te ||\n              (a((e = c(e))) || f(e) ? 0 !== e.length : !w(e) || 0 !== Object.keys(e).length)\n            )\n          }\n          gt() {\n            return !1\n          }\n          geq() {\n            return !1\n          }\n          lt() {\n            return !1\n          }\n          leq() {\n            return !1\n          }\n          valueOf() {\n            return \"\"\n          }\n        }\n        const re = new (class extends s {\n            equals(e) {\n              return d(c(e))\n            }\n            gt() {\n              return !1\n            }\n            geq() {\n              return !1\n            }\n            lt() {\n              return !1\n            }\n            leq() {\n              return !1\n            }\n            valueOf() {\n              return null\n            }\n          })(),\n          se = {\n            true: !0,\n            false: !1,\n            nil: re,\n            null: re,\n            empty: new te(),\n            blank: new (class extends te {\n              equals(e) {\n                return !1 === e || !!d(c(e)) || (a(e) ? /^\\s*$/.test(e) : super.equals(e))\n              }\n            })(),\n          }\n        class ne extends X {\n          constructor(e, t, r, s) {\n            super(U.Literal, e, t, r, s),\n              (this.input = e),\n              (this.begin = t),\n              (this.end = r),\n              (this.file = s),\n              (this.literal = this.getText())\n          }\n        }\n        const ie = {\n          \"==\": 1,\n          \"!=\": 1,\n          \">\": 1,\n          \"<\": 1,\n          \">=\": 1,\n          \"<=\": 1,\n          contains: 1,\n          and: 0,\n          or: 0,\n        }\n        class oe extends X {\n          constructor(e, t, r, s) {\n            super(U.Operator, e, t, r, s),\n              (this.input = e),\n              (this.begin = t),\n              (this.end = r),\n              (this.file = s),\n              (this.operator = this.getText())\n          }\n          getPrecedence() {\n            const e = this.getText()\n            return e in ie ? ie[e] : 1\n          }\n        }\n        const ae = /[\\da-fA-F]/,\n          le = /[0-7]/,\n          he = { b: \"\\b\", f: \"\\f\", n: \"\\n\", r: \"\\r\", t: \"\\t\", v: \"\\v\" }\n        function ce(e) {\n          const t = e.charCodeAt(0)\n          return t >= 97 ? t - 87 : t >= 65 ? t - 55 : t - 48\n        }\n        function ue(e) {\n          let t = \"\"\n          for (let r = 1; r < e.length - 1; r++)\n            if (\"\\\\\" === e[r])\n              if (void 0 !== he[e[r + 1]]) t += he[e[++r]]\n              else if (\"u\" === e[r + 1]) {\n                let s = 0,\n                  n = r + 2\n                for (; n <= r + 5 && ae.test(e[n]); ) s = 16 * s + ce(e[n++])\n                ;(r = n - 1), (t += String.fromCharCode(s))\n              } else if (le.test(e[r + 1])) {\n                let s = r + 1,\n                  n = 0\n                for (; s <= r + 3 && le.test(e[s]); ) n = 8 * n + ce(e[s++])\n                ;(r = s - 1), (t += String.fromCharCode(n))\n              } else t += e[++r]\n            else t += e[r]\n          return t\n        }\n        class pe extends X {\n          constructor(e, t, r) {\n            super(U.PropertyAccess, e.input, e.begin, r, e.file),\n              (this.variable = e),\n              (this.props = t)\n          }\n          getVariableAsText() {\n            return this.variable instanceof ee\n              ? this.variable.getText()\n              : ue(this.variable.getText())\n          }\n        }\n        function de(e, t) {\n          if (!e) {\n            const r = t ? t() : `expect ${e} to be true`\n            throw new V(r)\n          }\n        }\n        class fe extends X {\n          constructor(e, t, r, s, n, i) {\n            super(U.Filter, r, s, n, i), (this.name = e), (this.args = t)\n          }\n        }\n        class ge extends X {\n          constructor(e, t, r, s, n, i) {\n            super(U.Hash, e, t, r, i),\n              (this.input = e),\n              (this.begin = t),\n              (this.end = r),\n              (this.name = s),\n              (this.value = n),\n              (this.file = i)\n          }\n        }\n        class me extends X {\n          constructor(e, t, r, s) {\n            super(U.Quoted, e, t, r, s),\n              (this.input = e),\n              (this.begin = t),\n              (this.end = r),\n              (this.file = s)\n          }\n        }\n        class we extends X {\n          constructor(e, t, r, s) {\n            super(U.HTML, e, t, r, s),\n              (this.input = e),\n              (this.begin = t),\n              (this.end = r),\n              (this.file = s),\n              (this.trimLeft = 0),\n              (this.trimRight = 0)\n          }\n          getContent() {\n            return this.input.slice(this.begin + this.trimLeft, this.end - this.trimRight)\n          }\n        }\n        class Te extends X {\n          constructor(e, t, r, s, n, i, o, a) {\n            super(e, r, s, n, a),\n              (this.trimLeft = !1),\n              (this.trimRight = !1),\n              (this.content = this.getText())\n            const l = \"-\" === t[0],\n              h = \"-\" === m(t)\n            ;(this.content = t.slice(l ? 1 : 0, h ? -1 : t.length).trim()),\n              (this.trimLeft = l || i),\n              (this.trimRight = h || o)\n          }\n        }\n        class ye extends Te {\n          constructor(e, t, r, s, n) {\n            const {\n                trimTagLeft: i,\n                trimTagRight: o,\n                tagDelimiterLeft: a,\n                tagDelimiterRight: l,\n              } = s,\n              h = e.slice(t + a.length, r - l.length)\n            super(U.Tag, h, e, t, r, i, o, n)\n            const c = new qe(this.content, s.operatorsTrie)\n            if (((this.name = c.readIdentifier().getText()), !this.name))\n              throw new $(\"illegal tag syntax\", this)\n            c.skipBlank(), (this.args = c.remaining())\n          }\n        }\n        class be extends X {\n          constructor(e, t, r, s, n, i) {\n            super(U.Range, e, t, r, i),\n              (this.input = e),\n              (this.begin = t),\n              (this.end = r),\n              (this.lhs = s),\n              (this.rhs = n),\n              (this.file = i)\n          }\n        }\n        class ke extends Te {\n          constructor(e, t, r, s, n) {\n            const {\n                trimOutputLeft: i,\n                trimOutputRight: o,\n                outputDelimiterLeft: a,\n                outputDelimiterRight: l,\n              } = s,\n              h = e.slice(t + a.length, r - l.length)\n            super(U.Output, h, e, t, r, i, o, n)\n          }\n        }\n        class ve {\n          constructor(e) {\n            this.postfix = [...Se(e)]\n          }\n          *evaluate(e, t) {\n            de(e, () => \"unable to evaluate: context not defined\")\n            const r = []\n            for (const s of this.postfix)\n              if (H(s)) {\n                const t = yield r.pop(),\n                  n = yield r.pop(),\n                  i = Oe(e.opts.operators, s, n, t, e)\n                r.push(i)\n              } else r.push(yield _e(s, e, t && 1 === this.postfix.length))\n            return r[0]\n          }\n        }\n        function _e(e, t, r = !1) {\n          return Q(e) === U.PropertyAccess\n            ? (function (e, t, r) {\n                const s = e.getVariableAsText(),\n                  n = e.props.map((e) => _e(e, t, !1))\n                try {\n                  return t.get([s, ...n])\n                } catch (t) {\n                  if (r && \"InternalUndefinedVariableError\" === t.name) return null\n                  throw new B(t, e)\n                }\n              })(e, t, r)\n            : (function (e) {\n                return Q(e) === U.Range\n              })(e)\n            ? (function (e, t) {\n                return T(+_e(e.lhs, t), +_e(e.rhs, t) + 1)\n              })(e, t)\n            : (function (e) {\n                return Q(e) === U.Literal\n              })(e)\n            ? (function (e) {\n                return se[e.literal]\n              })(e)\n            : (function (e) {\n                return Q(e) === U.Number\n              })(e)\n            ? (function (e) {\n                const t = e.whole.content + \".\" + (e.decimal ? e.decimal.content : \"\")\n                return Number(t)\n              })(e)\n            : (function (e) {\n                return Q(e) === U.Word\n              })(e)\n            ? e.getText()\n            : K(e)\n            ? xe(e)\n            : void 0\n        }\n        function xe(e) {\n          return ue(e.getText())\n        }\n        function Oe(e, t, r, s, n) {\n          return (0, e[t.operator])(r, s, n)\n        }\n        function* Se(e) {\n          const t = []\n          for (const r of e)\n            if (H(r)) {\n              for (; t.length && t[t.length - 1].getPrecedence() > r.getPrecedence(); )\n                yield t.pop()\n              t.push(r)\n            } else yield r\n          for (; t.length; ) yield t.pop()\n        }\n        class qe {\n          constructor(e, t, r = \"\") {\n            ;(this.input = e),\n              (this.trie = t),\n              (this.file = r),\n              (this.p = 0),\n              (this.rawBeginAt = -1),\n              (this.N = e.length)\n          }\n          readExpression() {\n            return new ve(this.readExpressionTokens())\n          }\n          *readExpressionTokens() {\n            const e = this.readValue()\n            if (e)\n              for (yield e; this.p < this.N; ) {\n                const e = this.readOperator()\n                if (!e) return\n                const t = this.readValue()\n                if (!t) return\n                yield e, yield t\n              }\n          }\n          readOperator() {\n            this.skipBlank()\n            const e = (function (e, t, r, s = e.length) {\n              let n,\n                i = r,\n                o = t\n              for (; i[e[o]] && o < s; ) (i = i[e[o++]]), i.end && (n = i)\n              return n ? (n.needBoundary && 1 & D[e.charCodeAt(o)] ? -1 : o) : -1\n            })(this.input, this.p, this.trie, this.p + 8)\n            if (-1 !== e) return new oe(this.input, this.p, (this.p = e), this.file)\n          }\n          readFilters() {\n            const e = []\n            for (;;) {\n              const t = this.readFilter()\n              if (!t) return e\n              e.push(t)\n            }\n          }\n          readFilter() {\n            if ((this.skipBlank(), this.end())) return null\n            de(\"|\" === this.peek(), () => `unexpected token at ${this.snapshot()}`), this.p++\n            const e = this.p,\n              t = this.readIdentifier()\n            if (!t.size()) return null\n            const r = []\n            if ((this.skipBlank(), \":\" === this.peek()))\n              do {\n                ++this.p\n                const e = this.readFilterArg()\n                for (\n                  e && r.push(e);\n                  this.p < this.N && \",\" !== this.peek() && \"|\" !== this.peek();\n\n                )\n                  ++this.p\n              } while (\",\" === this.peek())\n            return new fe(t.getText(), r, this.input, e, this.p, this.file)\n          }\n          readFilterArg() {\n            const e = this.readValue()\n            if (!e) return\n            if ((this.skipBlank(), \":\" !== this.peek())) return e\n            ++this.p\n            const t = this.readValue()\n            return [e.getText(), t]\n          }\n          readTopLevelTokens(e = M) {\n            const t = []\n            for (; this.p < this.N; ) {\n              const r = this.readTopLevelToken(e)\n              t.push(r)\n            }\n            return (\n              (function (e, t) {\n                let r = !1\n                for (let s = 0; s < e.length; s++) {\n                  const n = e[s]\n                  Q(n) & U.Delimited &&\n                    (!r && n.trimLeft && Z(e[s - 1], t.greedy),\n                    W(n) && (\"raw\" === n.name ? (r = !0) : \"endraw\" === n.name && (r = !1)),\n                    !r && n.trimRight && Y(e[s + 1], t.greedy))\n                }\n              })(t, e),\n              t\n            )\n          }\n          readTopLevelToken(e) {\n            const { tagDelimiterLeft: t, outputDelimiterLeft: r } = e\n            return this.rawBeginAt > -1\n              ? this.readEndrawOrRawContent(e)\n              : this.match(t)\n              ? this.readTagToken(e)\n              : this.match(r)\n              ? this.readOutputToken(e)\n              : this.readHTMLToken(e)\n          }\n          readHTMLToken(e) {\n            const t = this.p\n            for (; this.p < this.N; ) {\n              const { tagDelimiterLeft: t, outputDelimiterLeft: r } = e\n              if (this.match(t)) break\n              if (this.match(r)) break\n              ++this.p\n            }\n            return new we(this.input, t, this.p, this.file)\n          }\n          readTagToken(e = M) {\n            const { file: t, input: r } = this,\n              s = this.p\n            if (-1 === this.readToDelimiter(e.tagDelimiterRight))\n              throw this.mkError(`tag ${this.snapshot(s)} not closed`, s)\n            const n = new ye(r, s, this.p, e, t)\n            return \"raw\" === n.name && (this.rawBeginAt = s), n\n          }\n          readToDelimiter(e) {\n            for (; this.p < this.N; )\n              if (8 & this.peekType()) this.readQuoted()\n              else if ((++this.p, this.rmatch(e))) return this.p\n            return -1\n          }\n          readOutputToken(e = M) {\n            const { file: t, input: r } = this,\n              { outputDelimiterRight: s } = e,\n              n = this.p\n            if (-1 === this.readToDelimiter(s))\n              throw this.mkError(`output ${this.snapshot(n)} not closed`, n)\n            return new ke(r, n, this.p, e, t)\n          }\n          readEndrawOrRawContent(e) {\n            const { tagDelimiterLeft: t, tagDelimiterRight: r } = e,\n              s = this.p\n            let n = this.readTo(t) - t.length\n            for (; this.p < this.N; )\n              if (\"endraw\" === this.readIdentifier().getText())\n                for (; this.p <= this.N; ) {\n                  if (this.rmatch(r)) {\n                    const t = this.p\n                    return s === n\n                      ? ((this.rawBeginAt = -1), new ye(this.input, s, t, e, this.file))\n                      : ((this.p = n), new we(this.input, s, n, this.file))\n                  }\n                  if (this.rmatch(t)) break\n                  this.p++\n                }\n              else n = this.readTo(t) - t.length\n            throw this.mkError(`raw ${this.snapshot(this.rawBeginAt)} not closed`, s)\n          }\n          mkError(e, t) {\n            return new $(e, new ee(this.input, t, this.N, this.file))\n          }\n          snapshot(e = this.p) {\n            return JSON.stringify(\n              (16, (t = this.input.slice(e)).length > 16 ? t.substr(0, 13) + \"...\" : t)\n            )\n            var t\n          }\n          readWord() {\n            return (\n              console.warn(\"Tokenizer#readWord() will be removed, use #readIdentifier instead\"),\n              this.readIdentifier()\n            )\n          }\n          readIdentifier() {\n            this.skipBlank()\n            const e = this.p\n            for (; 1 & this.peekType(); ) ++this.p\n            return new ee(this.input, e, this.p, this.file)\n          }\n          readHashes() {\n            const e = []\n            for (;;) {\n              const t = this.readHash()\n              if (!t) return e\n              e.push(t)\n            }\n          }\n          readHash() {\n            this.skipBlank(), \",\" === this.peek() && ++this.p\n            const e = this.p,\n              t = this.readIdentifier()\n            if (!t.size()) return\n            let r\n            return (\n              this.skipBlank(),\n              \":\" === this.peek() && (++this.p, (r = this.readValue())),\n              new ge(this.input, e, this.p, t, r, this.file)\n            )\n          }\n          remaining() {\n            return this.input.slice(this.p)\n          }\n          advance(e = 1) {\n            this.p += e\n          }\n          end() {\n            return this.p >= this.N\n          }\n          readTo(e) {\n            for (; this.p < this.N; ) if ((++this.p, this.rmatch(e))) return this.p\n            return -1\n          }\n          readValue() {\n            const e = this.readQuoted() || this.readRange()\n            if (e) return e\n            if (\"[\" === this.peek()) {\n              this.p++\n              const e = this.readQuoted()\n              if (!e) return\n              if (\"]\" !== this.peek()) return\n              return this.p++, new pe(e, [], this.p)\n            }\n            const t = this.readIdentifier()\n            if (!t.size()) return\n            let r = t.isNumber(!0)\n            const s = []\n            for (;;)\n              if (\"[\" === this.peek()) {\n                ;(r = !1), this.p++\n                const e = this.readValue() || new ee(this.input, this.p, this.p, this.file)\n                this.readTo(\"]\"), s.push(e)\n              } else {\n                if (\".\" !== this.peek() || \".\" === this.peek(1)) break\n                {\n                  this.p++\n                  const e = this.readIdentifier()\n                  if (!e.size()) break\n                  e.isNumber() || (r = !1), s.push(e)\n                }\n              }\n            return !s.length && se.hasOwnProperty(t.content)\n              ? new ne(this.input, t.begin, t.end, this.file)\n              : r\n              ? new G(t, s[0])\n              : new pe(t, s, this.p)\n          }\n          readRange() {\n            this.skipBlank()\n            const e = this.p\n            if (\"(\" !== this.peek()) return\n            ++this.p\n            const t = this.readValueOrThrow()\n            this.p += 2\n            const r = this.readValueOrThrow()\n            return ++this.p, new be(this.input, e, this.p, t, r, this.file)\n          }\n          readValueOrThrow() {\n            const e = this.readValue()\n            return de(e, () => `unexpected token ${this.snapshot()}, value expected`), e\n          }\n          readQuoted() {\n            this.skipBlank()\n            const e = this.p\n            if (!(8 & this.peekType())) return\n            ++this.p\n            let t = !1\n            for (; this.p < this.N && (++this.p, this.input[this.p - 1] !== this.input[e] || t); )\n              t ? (t = !1) : \"\\\\\" === this.input[this.p - 1] && (t = !0)\n            return new me(this.input, e, this.p, this.file)\n          }\n          readFileName() {\n            const e = this.p\n            for (; !(4 & this.peekType()) && \",\" !== this.peek() && this.p < this.N; ) this.p++\n            return new ee(this.input, e, this.p, this.file)\n          }\n          match(e) {\n            for (let t = 0; t < e.length; t++) if (e[t] !== this.input[this.p + t]) return !1\n            return !0\n          }\n          rmatch(e) {\n            for (let t = 0; t < e.length; t++)\n              if (e[e.length - 1 - t] !== this.input[this.p - 1 - t]) return !1\n            return !0\n          }\n          peekType(e = 0) {\n            return D[this.input.charCodeAt(this.p + e)]\n          }\n          peek(e = 0) {\n            return this.input[this.p + e]\n          }\n          skipBlank() {\n            for (; 4 & this.peekType(); ) ++this.p\n          }\n        }\n        class Ee {\n          constructor(e) {\n            ;(this.html = \"\"),\n              (this.break = !1),\n              (this.continue = !1),\n              (this.keepOutputType = !1),\n              (this.keepOutputType = e)\n          }\n          write(e) {\n            ;(e = !0 === this.keepOutputType ? c(e) : h(c(e))),\n              !0 === this.keepOutputType && \"string\" != typeof e && \"\" === this.html\n                ? (this.html = e)\n                : (this.html = h(this.html) + h(e))\n          }\n        }\n        class Re {\n          *renderTemplates(e, t, r) {\n            r || (r = new Ee(t.opts.keepOutputType))\n            for (const s of e)\n              try {\n                const e = yield s.render(t, r)\n                if ((e && r.write(e), r.break || r.continue)) break\n              } catch (e) {\n                throw I.is(e) ? e : new I(e, s)\n              }\n            return r.html\n          }\n        }\n        class Ae {\n          constructor(e, t) {\n            ;(this.handlers = {}),\n              (this.stopRequested = !1),\n              (this.tokens = e),\n              (this.parseToken = t)\n          }\n          on(e, t) {\n            return (this.handlers[e] = t), this\n          }\n          trigger(e, t) {\n            const r = this.handlers[e]\n            return !!r && (r(t), !0)\n          }\n          start() {\n            let e\n            for (this.trigger(\"start\"); !this.stopRequested && (e = this.tokens.shift()); ) {\n              if (this.trigger(\"token\", e)) continue\n              if (W(e) && this.trigger(`tag:${e.name}`, e)) continue\n              const t = this.parseToken(e, this.tokens)\n              this.trigger(\"template\", t)\n            }\n            return this.stopRequested || this.trigger(\"end\"), this\n          }\n          stop() {\n            return (this.stopRequested = !0), this\n          }\n        }\n        class De {\n          constructor(e) {\n            this.token = e\n          }\n        }\n        class Fe {\n          constructor(e) {\n            this.hash = {}\n            const t = new qe(e, {})\n            for (const e of t.readHashes()) this.hash[e.name.content] = e.value\n          }\n          *render(e) {\n            const t = {}\n            for (const r of Object.keys(this.hash)) t[r] = yield _e(this.hash[r], e)\n            return t\n          }\n        }\n        class Me {\n          constructor(e, t, r, s) {\n            ;(this.name = e), (this.impl = t || k), (this.args = r), (this.liquid = s)\n          }\n          render(e, t) {\n            const r = []\n            for (const e of this.args) f(e) ? r.push([e[0], _e(e[1], t)]) : r.push(_e(e, t))\n            return this.impl.apply({ context: t, liquid: this.liquid }, [e, ...r])\n          }\n        }\n        class Le {\n          constructor(e, t) {\n            this.filters = []\n            const r = new qe(e, t.options.operatorsTrie)\n            ;(this.initial = r.readExpression()),\n              (this.filters = r\n                .readFilters()\n                .map(({ name: e, args: r }) => new Me(e, t.filters.get(e), r, t)))\n          }\n          *value(e, t) {\n            t =\n              t ||\n              (e.opts.lenientIf && this.filters.length > 0 && \"default\" === this.filters[0].name)\n            let r = yield this.initial.evaluate(e, t)\n            for (const t of this.filters) r = yield t.render(r, e)\n            return r\n          }\n        }\n        function Pe(e) {\n          const t = { then: (t) => t(e), catch: () => t }\n          return t\n        }\n        function Ne(e) {\n          const t = { then: (r, s) => (s ? s(e) : t), catch: (t) => t(e) }\n          return t\n        }\n        function $e(e) {\n          return (function (e) {\n            return e && l(e.then)\n          })(e)\n            ? e\n            : (function (e) {\n                return e && l(e.next) && l(e.throw) && l(e.return)\n              })(e)\n            ? (function t(r) {\n                let s\n                try {\n                  s = e.next(r)\n                } catch (e) {\n                  return Ne(e)\n                }\n                return s.done\n                  ? Pe(s.value)\n                  : $e(s.value).then(t, (r) => {\n                      let s\n                      try {\n                        s = e.throw(r)\n                      } catch (e) {\n                        return Ne(e)\n                      }\n                      return s.done ? Pe(s.value) : t(s.value)\n                    })\n              })()\n            : Pe(e)\n        }\n        function Ce(e) {\n          return Promise.resolve($e(e))\n        }\n        function Ie(e) {\n          let t\n          return (\n            $e(e)\n              .then((e) => ((t = e), Pe(t)))\n              .catch((e) => {\n                throw e\n              }),\n            t\n          )\n        }\n        class Be extends De {\n          constructor(e, t, r) {\n            super(e), (this.name = e.name)\n            const s = r.tags.get(e.name)\n            ;(this.impl = Object.create(s)),\n              (this.impl.liquid = r),\n              this.impl.parse && this.impl.parse(e, t)\n          }\n          *render(e, t) {\n            const r = yield new Fe(this.token.args).render(e),\n              s = this.impl\n            if (l(s.render)) return yield s.render(e, t, r)\n          }\n        }\n        class je extends De {\n          constructor(e, t) {\n            super(e), (this.value = new Le(e.content, t))\n          }\n          *render(e, t) {\n            const r = yield this.value.value(e, !1)\n            t.write(r)\n          }\n        }\n        class Ve extends De {\n          constructor(e) {\n            super(e), (this.str = e.getContent())\n          }\n          *render(e, t) {\n            t.write(this.str)\n          }\n        }\n        class ze {\n          constructor(e) {\n            this.liquid = e\n          }\n          parse(e) {\n            let t\n            const r = []\n            for (; (t = e.shift()); ) r.push(this.parseToken(t, e))\n            return r\n          }\n          parseToken(e, t) {\n            try {\n              return W(e)\n                ? new Be(e, t, this.liquid)\n                : Q(e) === U.Output\n                ? new je(e, this.liquid)\n                : new Ve(e)\n            } catch (t) {\n              throw new C(t, e)\n            }\n          }\n          parseStream(e) {\n            return new Ae(e, (e, t) => this.parseToken(e, t))\n          }\n        }\n        var Ue = {\n          parse: function (e) {\n            const t = new qe(e.args, this.liquid.options.operatorsTrie)\n            ;(this.key = t.readIdentifier().content),\n              t.skipBlank(),\n              de(\"=\" === t.peek(), () => `illegal token ${e.getText()}`),\n              t.advance(),\n              (this.value = t.remaining())\n          },\n          render: function* (e) {\n            e.bottom()[this.key] = yield this.liquid._evalValue(this.value, e)\n          },\n        }\n        function He(e) {\n          return f(e)\n            ? e\n            : a(e) && e.length > 0\n            ? [e]\n            : w(e)\n            ? Object.keys(e).map((t) => [t, e[t]])\n            : []\n        }\n        function Je(e) {\n          return f(e) ? e : [e]\n        }\n        class We extends s {\n          constructor(e) {\n            super(), (this.i = 0), (this.length = e)\n          }\n          next() {\n            this.i++\n          }\n          index0() {\n            return this.i\n          }\n          index() {\n            return this.i + 1\n          }\n          first() {\n            return 0 === this.i\n          }\n          last() {\n            return this.i === this.length - 1\n          }\n          rindex() {\n            return this.length - this.i\n          }\n          rindex0() {\n            return this.length - this.i - 1\n          }\n          valueOf() {\n            return JSON.stringify(this)\n          }\n        }\n        var Ke,\n          Qe = {\n            type: \"block\",\n            parse: function (e, t) {\n              const r = new qe(e.args, this.liquid.options.operatorsTrie),\n                s = r.readIdentifier(),\n                n = r.readIdentifier(),\n                i = r.readValue()\n              let o\n              de(s.size() && \"in\" === n.content && i, () => `illegal tag: ${e.getText()}`),\n                (this.variable = s.content),\n                (this.collection = i),\n                (this.hash = new Fe(r.remaining())),\n                (this.templates = []),\n                (this.elseTemplates = [])\n              const a = this.liquid.parser\n                .parseStream(t)\n                .on(\"start\", () => (o = this.templates))\n                .on(\"tag:else\", () => (o = this.elseTemplates))\n                .on(\"tag:endfor\", () => a.stop())\n                .on(\"template\", (e) => o.push(e))\n                .on(\"end\", () => {\n                  throw new Error(`tag ${e.getText()} not closed`)\n                })\n              a.start()\n            },\n            render: function* (e, t) {\n              const r = this.liquid.renderer\n              let s = He(yield _e(this.collection, e))\n              if (!s.length) return void (yield r.renderTemplates(this.elseTemplates, e, t))\n              const n = yield this.hash.render(e),\n                i = n.offset || 0,\n                o = void 0 === n.limit ? s.length : n.limit\n              ;(s = s.slice(i, i + o)), \"reversed\" in n && s.reverse()\n              const a = { forloop: new We(s.length) }\n              e.push(a)\n              for (const n of s) {\n                if (\n                  ((a[this.variable] = n), yield r.renderTemplates(this.templates, e, t), t.break)\n                ) {\n                  t.break = !1\n                  break\n                }\n                ;(t.continue = !1), a.forloop.next()\n              }\n              e.pop()\n            },\n          },\n          Ze = {\n            parse: function (e, t) {\n              const r = new qe(e.args, this.liquid.options.operatorsTrie)\n              ;(this.variable = (function (e) {\n                const t = e.readIdentifier().content\n                if (t) return t\n                const r = e.readQuoted()\n                return r ? xe(r) : void 0\n              })(r)),\n                de(this.variable, () => `${e.args} not valid identifier`),\n                (this.templates = [])\n              const s = this.liquid.parser.parseStream(t)\n              s\n                .on(\"tag:endcapture\", () => s.stop())\n                .on(\"template\", (e) => this.templates.push(e))\n                .on(\"end\", () => {\n                  throw new Error(`tag ${e.getText()} not closed`)\n                }),\n                s.start()\n            },\n            render: function* (e) {\n              const t = this.liquid.renderer,\n                r = yield t.renderTemplates(this.templates, e)\n              e.bottom()[this.variable] = r\n            },\n          },\n          Ye = {\n            parse: function (e, t) {\n              ;(this.cond = new Le(e.args, this.liquid)),\n                (this.cases = []),\n                (this.elseTemplates = [])\n              let r = []\n              const s = this.liquid.parser\n                .parseStream(t)\n                .on(\"tag:when\", (e) => {\n                  r = []\n                  const t = new qe(e.args, this.liquid.options.operatorsTrie)\n                  for (; !t.end(); ) {\n                    const e = t.readValue()\n                    e && this.cases.push({ val: e, templates: r }), t.readTo(\",\")\n                  }\n                })\n                .on(\"tag:else\", () => (r = this.elseTemplates))\n                .on(\"tag:endcase\", () => s.stop())\n                .on(\"template\", (e) => r.push(e))\n                .on(\"end\", () => {\n                  throw new Error(`tag ${e.getText()} not closed`)\n                })\n              s.start()\n            },\n            render: function* (e, t) {\n              const r = this.liquid.renderer,\n                s = c(yield this.cond.value(e, e.opts.lenientIf))\n              for (const n of this.cases)\n                if (_e(n.val, e, e.opts.lenientIf) === s)\n                  return void (yield r.renderTemplates(n.templates, e, t))\n              yield r.renderTemplates(this.elseTemplates, e, t)\n            },\n          },\n          Xe = {\n            parse: function (e, t) {\n              const r = this.liquid.parser.parseStream(t)\n              r\n                .on(\"token\", (e) => {\n                  \"endcomment\" === e.name && r.stop()\n                })\n                .on(\"end\", () => {\n                  throw new Error(`tag ${e.getText()} not closed`)\n                }),\n                r.start()\n            },\n          }\n        !(function (e) {\n          ;(e[(e.OUTPUT = 0)] = \"OUTPUT\"), (e[(e.STORE = 1)] = \"STORE\")\n        })(Ke || (Ke = {}))\n        var Ge = Ke,\n          et = {\n            parse: function (e) {\n              const t = e.args,\n                r = new qe(t, this.liquid.options.operatorsTrie)\n              ;(this.file = this.liquid.options.dynamicPartials ? r.readValue() : r.readFileName()),\n                de(this.file, () => `illegal argument \"${e.args}\"`)\n              const s = r.p\n              \"with\" === r.readIdentifier().content\n                ? (r.skipBlank(), \":\" !== r.peek() ? (this.withVar = r.readValue()) : (r.p = s))\n                : (r.p = s),\n                (this.hash = new Fe(r.remaining()))\n            },\n            render: function* (e, t) {\n              const { liquid: r, hash: s, withVar: n, file: i } = this,\n                { renderer: o } = r,\n                a = e.opts.dynamicPartials\n                  ? K(i)\n                    ? yield o.renderTemplates(r.parse(xe(i)), e)\n                    : yield _e(i, e)\n                  : i.getText()\n              de(a, () => `illegal filename \"${i.getText()}\":\"${a}\"`)\n              const l = e.saveRegister(\"blocks\", \"blockMode\")\n              e.setRegister(\"blocks\", {}), e.setRegister(\"blockMode\", Ge.OUTPUT)\n              const h = yield s.render(e)\n              n && (h[a] = _e(n, e))\n              const c = yield r._parseFile(a, e.opts, e.sync)\n              e.push(h), yield o.renderTemplates(c, e, t), e.pop(), e.restoreRegister(l)\n            },\n          },\n          tt = {\n            parse: function (e) {\n              const t = e.args,\n                r = new qe(t, this.liquid.options.operatorsTrie)\n              for (\n                this.file = this.liquid.options.dynamicPartials ? r.readValue() : r.readFileName(),\n                  de(this.file, () => `illegal argument \"${e.args}\"`);\n                !r.end();\n\n              ) {\n                r.skipBlank()\n                const e = r.p,\n                  t = r.readIdentifier()\n                if (\n                  (\"with\" === t.content || \"for\" === t.content) &&\n                  (r.skipBlank(), \":\" !== r.peek())\n                ) {\n                  const e = r.readValue()\n                  if (e) {\n                    const s = r.p\n                    let n\n                    \"as\" === r.readIdentifier().content ? (n = r.readIdentifier()) : (r.p = s),\n                      (this[t.content] = { value: e, alias: n && n.content }),\n                      r.skipBlank(),\n                      \",\" === r.peek() && r.advance()\n                    continue\n                  }\n                }\n                r.p = e\n                break\n              }\n              this.hash = new Fe(r.remaining())\n            },\n            render: function* (e, t) {\n              const { liquid: r, file: s, hash: n } = this,\n                { renderer: i } = r,\n                o = e.opts.dynamicPartials\n                  ? K(s)\n                    ? yield i.renderTemplates(r.parse(xe(s)), e)\n                    : _e(s, e)\n                  : s.getText()\n              de(o, () => `illegal filename \"${s.getText()}\":\"${o}\"`)\n              const a = new z({}, e.opts, e.sync),\n                l = yield n.render(e)\n              if (this.with) {\n                const { value: t, alias: r } = this.with\n                l[r || o] = _e(t, e)\n              }\n              if ((a.push(l), this.for)) {\n                const { value: s, alias: n } = this.for\n                let h = _e(s, e)\n                ;(h = He(h)), (l.forloop = new We(h.length))\n                for (const e of h) {\n                  l[n] = e\n                  const s = yield r._parseFile(o, a.opts, a.sync)\n                  yield i.renderTemplates(s, a, t), l.forloop.next()\n                }\n              } else {\n                const e = yield r._parseFile(o, a.opts, a.sync)\n                yield i.renderTemplates(e, a, t)\n              }\n            },\n          },\n          rt = {\n            parse: function (e) {\n              const t = new qe(e.args, this.liquid.options.operatorsTrie)\n              this.variable = t.readIdentifier().content\n            },\n            render: function (e, t) {\n              const r = e.environments\n              u(r[this.variable]) || (r[this.variable] = 0), t.write(h(--r[this.variable]))\n            },\n          },\n          st = {\n            parse: function (e) {\n              const t = new qe(e.args, this.liquid.options.operatorsTrie),\n                r = t.readValue()\n              for (\n                t.skipBlank(),\n                  this.candidates = [],\n                  r &&\n                    (\":\" === t.peek() ? ((this.group = r), t.advance()) : this.candidates.push(r));\n                !t.end();\n\n              ) {\n                const e = t.readValue()\n                e && this.candidates.push(e), t.readTo(\",\")\n              }\n              de(this.candidates.length, () => `empty candidates: ${e.getText()}`)\n            },\n            render: function (e, t) {\n              const r = `cycle:${_e(this.group, e)}:` + this.candidates.join(\",\"),\n                s = e.getRegister(\"cycle\")\n              let n = s[r]\n              void 0 === n && (n = s[r] = 0)\n              const i = this.candidates[n]\n              ;(n = (n + 1) % this.candidates.length), (s[r] = n)\n              const o = _e(i, e)\n              t.write(o)\n            },\n          },\n          nt = {\n            parse: function (e, t) {\n              let r\n              ;(this.branches = []), (this.elseTemplates = [])\n              const s = this.liquid.parser\n                .parseStream(t)\n                .on(\"start\", () =>\n                  this.branches.push({ cond: new Le(e.args, this.liquid), templates: (r = []) })\n                )\n                .on(\"tag:elsif\", (e) => {\n                  this.branches.push({ cond: new Le(e.args, this.liquid), templates: (r = []) })\n                })\n                .on(\"tag:else\", () => (r = this.elseTemplates))\n                .on(\"tag:endif\", () => s.stop())\n                .on(\"template\", (e) => r.push(e))\n                .on(\"end\", () => {\n                  throw new Error(`tag ${e.getText()} not closed`)\n                })\n              s.start()\n            },\n            render: function* (e, t) {\n              const r = this.liquid.renderer\n              for (const s of this.branches)\n                if (E(yield s.cond.value(e, e.opts.lenientIf), e))\n                  return void (yield r.renderTemplates(s.templates, e, t))\n              yield r.renderTemplates(this.elseTemplates, e, t)\n            },\n          },\n          it = {\n            parse: function (e) {\n              const t = new qe(e.args, this.liquid.options.operatorsTrie)\n              this.variable = t.readIdentifier().content\n            },\n            render: function (e, t) {\n              const r = e.environments\n              u(r[this.variable]) || (r[this.variable] = 0)\n              const s = r[this.variable]\n              r[this.variable]++, t.write(h(s))\n            },\n          },\n          ot = {\n            parse: function (e, t) {\n              const r = new qe(e.args, this.liquid.options.operatorsTrie),\n                s = this.liquid.options.dynamicPartials ? r.readValue() : r.readFileName()\n              de(s, () => `illegal argument \"${e.args}\"`),\n                (this.file = s),\n                (this.hash = new Fe(r.remaining())),\n                (this.tpls = this.liquid.parser.parse(t))\n            },\n            render: function* (e, t) {\n              const { liquid: r, hash: s, file: n } = this,\n                { renderer: i } = r\n              if (\"none\" === n.getText()) {\n                e.setRegister(\"blockMode\", Ge.OUTPUT)\n                const r = yield i.renderTemplates(this.tpls, e)\n                return void t.write(r)\n              }\n              const o = e.opts.dynamicPartials\n                ? K(n)\n                  ? yield i.renderTemplates(r.parse(xe(n)), e)\n                  : _e(this.file, e)\n                : n.getText()\n              de(o, () => `file \"${n.getText()}\"(\"${o}\") not available`)\n              const a = yield r._parseFile(o, e.opts, e.sync)\n              e.setRegister(\"blockMode\", Ge.STORE)\n              const l = yield i.renderTemplates(this.tpls, e),\n                h = e.getRegister(\"blocks\")\n              void 0 === h[\"\"] && (h[\"\"] = () => l),\n                e.setRegister(\"blockMode\", Ge.OUTPUT),\n                e.push(yield s.render(e))\n              const c = yield i.renderTemplates(a, e)\n              e.pop(), t.write(c)\n            },\n          }\n        class at extends s {\n          constructor(e = () => \"\") {\n            super(), (this.superBlockRender = e)\n          }\n          super() {\n            return this.superBlockRender()\n          }\n        }\n        var lt = {\n            parse(e, t) {\n              const r = /\\w+/.exec(e.args)\n              ;(this.block = r ? r[0] : \"\"), (this.tpls = [])\n              const s = this.liquid.parser\n                .parseStream(t)\n                .on(\"tag:endblock\", () => s.stop())\n                .on(\"template\", (e) => this.tpls.push(e))\n                .on(\"end\", () => {\n                  throw new Error(`tag ${e.getText()} not closed`)\n                })\n              s.start()\n            },\n            *render(e, t) {\n              const r = this.getBlockRender(e)\n              yield this.emitHTML(e, t, r)\n            },\n            getBlockRender(e) {\n              const { liquid: t, tpls: r } = this,\n                s = e.getRegister(\"blocks\")[this.block],\n                n = function* (s) {\n                  e.push({ block: s })\n                  const n = yield t.renderer.renderTemplates(r, e)\n                  return e.pop(), n\n                }\n              return s ? (e) => s(new at(() => n(e))) : n\n            },\n            *emitHTML(e, t, r) {\n              e.getRegister(\"blockMode\", Ge.OUTPUT) === Ge.STORE\n                ? (e.getRegister(\"blocks\")[this.block] = r)\n                : t.write(yield r(new at()))\n            },\n          },\n          ht = {\n            parse: function (e, t) {\n              this.tokens = []\n              const r = this.liquid.parser.parseStream(t)\n              r\n                .on(\"token\", (e) => {\n                  \"endraw\" === e.name ? r.stop() : this.tokens.push(e)\n                })\n                .on(\"end\", () => {\n                  throw new Error(`tag ${e.getText()} not closed`)\n                }),\n                r.start()\n            },\n            render: function () {\n              return this.tokens.map((e) => e.getText()).join(\"\")\n            },\n          }\n        class ct extends We {\n          constructor(e, t) {\n            super(e), (this.length = e), (this.cols = t)\n          }\n          row() {\n            return Math.floor(this.i / this.cols) + 1\n          }\n          col0() {\n            return this.i % this.cols\n          }\n          col() {\n            return this.col0() + 1\n          }\n          col_first() {\n            return 0 === this.col0()\n          }\n          col_last() {\n            return this.col() === this.cols\n          }\n        }\n        const ut = {\n            assign: Ue,\n            for: Qe,\n            capture: Ze,\n            case: Ye,\n            comment: Xe,\n            include: et,\n            render: tt,\n            decrement: rt,\n            increment: it,\n            cycle: st,\n            if: nt,\n            layout: ot,\n            block: lt,\n            raw: ht,\n            tablerow: {\n              parse: function (e, t) {\n                const r = new qe(e.args, this.liquid.options.operatorsTrie)\n                ;(this.variable = r.readIdentifier()), r.skipBlank()\n                const s = r.readIdentifier()\n                let n\n                de(s && \"in\" === s.content, () => `illegal tag: ${e.getText()}`),\n                  (this.collection = r.readValue()),\n                  (this.hash = new Fe(r.remaining())),\n                  (this.templates = [])\n                const i = this.liquid.parser\n                  .parseStream(t)\n                  .on(\"start\", () => (n = this.templates))\n                  .on(\"tag:endtablerow\", () => i.stop())\n                  .on(\"template\", (e) => n.push(e))\n                  .on(\"end\", () => {\n                    throw new Error(`tag ${e.getText()} not closed`)\n                  })\n                i.start()\n              },\n              render: function* (e, t) {\n                let r = He(yield _e(this.collection, e))\n                const s = yield this.hash.render(e),\n                  n = s.offset || 0,\n                  i = void 0 === s.limit ? r.length : s.limit\n                r = r.slice(n, n + i)\n                const o = s.cols || r.length,\n                  a = this.liquid.renderer,\n                  l = new ct(r.length, o),\n                  h = { tablerowloop: l }\n                e.push(h)\n                for (let s = 0; s < r.length; s++, l.next())\n                  (h[this.variable.content] = r[s]),\n                    0 === l.col0() &&\n                      (1 !== l.row("

    invoke-virtual {v0, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    const-string v1, ") && t.write(\"</tr>\"), t.write(`<tr class=\"row${l.row()}\">`)),\n                    t.write(`<td class=\"col${l.col()}\">`),\n                    yield a.renderTemplates(this.templates, e, t),\n                    t.write(\"</td>\")\n                r.length && t.write(\"</tr>\"), e.pop()\n              },\n            },\n            unless: {\n              parse: function (e, t) {\n                let r\n                ;(this.templates = []), (this.branches = []), (this.elseTemplates = [])\n                const s = this.liquid.parser\n                  .parseStream(t)\n                  .on(\"start\", () => {\n                    ;(r = this.templates), (this.cond = new Le(e.args, this.liquid))\n                  })\n                  .on(\"tag:elsif\", (e) => {\n                    this.branches.push({ cond: new Le(e.args, this.liquid), templates: (r = []) })\n                  })\n                  .on(\"tag:else\", () => (r = this.elseTemplates))\n                  .on(\"tag:endunless\", () => s.stop())\n                  .on(\"template\", (e) => r.push(e))\n                  .on(\"end\", () => {\n                    throw new Error(`tag ${e.getText()} not closed`)\n                  })\n                s.start()\n              },\n              render: function* (e, t) {\n                const r = this.liquid.renderer\n                if (R(yield this.cond.value(e, e.opts.lenientIf), e))\n                  yield r.renderTemplates(this.templates, e, t)\n                else {\n                  for (const s of this.branches)\n                    if (E(yield s.cond.value(e, e.opts.lenientIf), e))\n                      return void (yield r.renderTemplates(s.templates, e, t))\n                  yield r.renderTemplates(this.elseTemplates, e, t)\n                }\n              },\n            },\n            break: {\n              render: function (e, t) {\n                t.break = !0\n              },\n            },\n            continue: {\n              render: function (e, t) {\n                t.continue = !0\n              },\n            },\n          },\n          pt = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", \'\"\': \"&#34;\", \"\'\": \"&#39;\" },\n          dt = { \"&amp;\": \"&\", \"&lt;\": \"<\", \"&gt;\": \">\", \"&#34;\": \'\"\', \"&#39;\": \"\'\" }\n        function ft(e) {\n          return h(e).replace(/&|<|>|\"|\'/g, (e) => pt[e])\n        }\n        const gt = Math.abs,\n          mt = Math.max,\n          wt = Math.min,\n          Tt = Math.ceil,\n          yt = Math.floor,\n          bt = /%([-_0^#:]+)?(\\d+)?([EO])?(.)/,\n          kt = [\n            \"January\",\n            \"February\",\n            \"March\",\n            \"April\",\n            \"May\",\n            \"June\",\n            \"July\",\n            \"August\",\n            \"September\",\n            \"October\",\n            \"November\",\n            \"December\",\n          ],\n          vt = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n          _t = kt.map(St),\n          xt = vt.map(St),\n          Ot = { 1: \"st\", 2: \"nd\", 3: \"rd\", default: \"th\" }\n        function St(e) {\n          return e.slice(0, 3)\n        }\n        function qt(e) {\n          return [\n            31,\n            (function (e) {\n              const t = e.getFullYear()\n              return !(0 != (3 & t) || !(t % 100 || (t % 400 == 0 && t)))\n            })(e)\n              ? 29\n              : 28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31,\n          ]\n        }\n        function Et(e) {\n          let t = 0\n          for (let r = 0; r < e.getMonth(); ++r) t += qt(e)[r]\n          return t + e.getDate()\n        }\n        function Rt(e, t) {\n          const r = Et(e) + (t - e.getDay()),\n            s = 7 - new Date(e.getFullYear(), 0, 1).getDay() + t\n          return String(Math.floor((r - s) / 7) + 1)\n        }\n        const At = { d: 2, e: 2, H: 2, I: 2, j: 3, k: 2, l: 2, L: 3, m: 2, M: 2, S: 2, U: 2, W: 2 },\n          Dt = { a: \" \", A: \" \", b: \" \", B: \" \", c: \" \", e: \" \", k: \" \", l: \" \", p: \" \", P: \" \" },\n          Ft = {\n            a: (e) => xt[e.getDay()],\n            A: (e) => vt[e.getDay()],\n            b: (e) => _t[e.getMonth()],\n            B: (e) => kt[e.getMonth()],\n            c: (e) => e.toLocaleString(),\n            C: (e) =>\n              (function (e) {\n                return parseInt(e.getFullYear().toString().substring(0, 2), 10)\n              })(e),\n            d: (e) => e.getDate(),\n            e: (e) => e.getDate(),\n            H: (e) => e.getHours(),\n            I: (e) => String(e.getHours() % 12 || 12),\n            j: (e) => Et(e),\n            k: (e) => e.getHours(),\n            l: (e) => String(e.getHours() % 12 || 12),\n            L: (e) => e.getMilliseconds(),\n            m: (e) => e.getMonth() + 1,\n            M: (e) => e.getMinutes(),\n            N: (e, t) => {\n              const r = Number(t.width) || 9\n              return (function (e, t, r = \" \") {\n                return b(e, t, r, (e, t) => e + t)\n              })(String(e.getMilliseconds()).substr(0, r), r, \"0\")\n            },\n            p: (e) => (e.getHours() < 12 ? \"AM\" : \"PM\"),\n            P: (e) => (e.getHours() < 12 ? \"am\" : \"pm\"),\n            q: (e) =>\n              (function (e) {\n                const t = e.getDate().toString(),\n                  r = parseInt(t.slice(-1))\n                return Ot[r] || Ot.default\n              })(e),\n            s: (e) => Math.round(e.valueOf() / 1e3),\n            S: (e) => e.getSeconds(),\n            u: (e) => e.getDay() || 7,\n            U: (e) => Rt(e, 0),\n            w: (e) => e.getDay(),\n            W: (e) => Rt(e, 1),\n            x: (e) => e.toLocaleDateString(),\n            X: (e) => e.toLocaleTimeString(),\n            y: (e) => e.getFullYear().toString().substring(2, 4),\n            Y: (e) => e.getFullYear(),\n            z: (e, t) => {\n              const r = e.getTimezoneOffset(),\n                s = Math.abs(r),\n                n = s % 60\n              return (\n                (r > 0 ? \"-\" : \"+\") +\n                y(Math.floor(s / 60), 2, \"0\") +\n                (t.flags[\":\"] ? \":\" : \"\") +\n                y(n, 2, \"0\")\n              )\n            },\n            t: () => \"\\t\",\n            n: () => \"\\n\",\n            \"%\": () => \"%\",\n          }\n        function Mt(e, t) {\n          const [r, s = \"\", n, i, o] = t,\n            a = Ft[o]\n          if (!a) return r\n          const l = {}\n          for (const e of s) l[e] = !0\n          let h = String(a(e, { flags: l, width: n, modifier: i })),\n            c = Dt[o] || \"0\",\n            u = n || At[o] || 0\n          var p\n          return (\n            l[\"^\"]\n              ? (h = h.toUpperCase())\n              : l[\"#\"] &&\n                ((p = h),\n                (h = [...p].some((e) => e >= \"a\" && e <= \"z\") ? p.toUpperCase() : p.toLowerCase())),\n            l._ ? (c = \" \") : l[0] && (c = \"0\"),\n            l[\"-\"] && (u = 0),\n            y(h, u, c)\n          )\n        }\n        Ft.h = Ft.b\n        class Lt extends Date {\n          constructor(e) {\n            super(e),\n              (this.dateString = e),\n              (this.ISO8601_TIMEZONE_PATTERN = /([zZ]|([+-])(\\d{2}):(\\d{2}))$/),\n              (this.inputTimezoneOffset = 0)\n            const t = e.match(this.ISO8601_TIMEZONE_PATTERN)\n            if (t && \"Z\" === t[1]) this.inputTimezoneOffset = this.getTimezoneOffset()\n            else if (t && t[2] && t[3] && t[4]) {\n              const [, , e, r, s] = t,\n                n = (\"+\" === e ? 1 : -1) * (60 * parseInt(r, 10) + parseInt(s, 10))\n              this.inputTimezoneOffset = this.getTimezoneOffset() + n\n            }\n          }\n          getDisplayDate() {\n            return new Date(+this + 60 * this.inputTimezoneOffset * 1e3)\n          }\n        }\n        var Pt = Object.freeze({\n          escape: ft,\n          escapeOnce: function (e) {\n            return ft(\n              (function (e) {\n                return String(e).replace(/&(amp|lt|gt|#34|#39);/g, (e) => dt[e])\n              })(e)\n            )\n          },\n          newlineToBr: function (e) {\n            return e.replace(/\\n/g, \"<br />\\n\")\n          },\n          stripHtml: function (e) {\n            return e.replace(/<script.*?<\\/script>|<!--.*?-->|<style.*?<\\/style>|<.*?>/g, \"\")\n          },\n          abs: gt,\n          atLeast: mt,\n          atMost: wt,\n          ceil: Tt,\n          dividedBy: (e, t) => e / t,\n          floor: yt,\n          minus: (e, t) => e - t,\n          modulo: (e, t) => e % t,\n          times: (e, t) => e * t,\n          round: function (e, t = 0) {\n            const r = Math.pow(10, t)\n            return Math.round(e * r) / r\n          },\n          plus: function (e, t) {\n            return Number(e) + Number(t)\n          },\n          sortNatural: function (e, t) {\n            return e && e.sort\n              ? void 0 !== t\n                ? [...e].sort((e, r) => _(e[t], r[t]))\n                : [...e].sort(_)\n              : []\n          },\n          urlDecode: (e) => e.split(\"+\").map(decodeURIComponent).join(\" \"),\n          urlEncode: (e) => e.split(\" \").map(encodeURIComponent).join(\"+\"),\n          join: (e, t) => e.join(void 0 === t ? \" \" : t),\n          last: (e) => (f(e) ? m(e) : \"\"),\n          first: (e) => (f(e) ? e[0] : \"\"),\n          reverse: (e) => [...e].reverse(),\n          sort: function (e, t) {\n            const r = (e) => (t ? this.context.getFromScope(e, t.split(\".\")) : e)\n            return Je(e).sort((e, t) => ((e = r(e)) < (t = r(t)) ? -1 : e > t ? 1 : 0))\n          },\n          size: (e) => (e && e.length) || 0,\n          map: function (e, t) {\n            return Je(e).map((e) => this.context.getFromScope(e, t.split(\".\")))\n          },\n          compact: function (e) {\n            return Je(e).filter((e) => !d(e))\n          },\n          concat: function (e, t) {\n            return Je(e).concat(t)\n          },\n          slice: function (e, t, r = 1) {\n            return (t = t < 0 ? e.length + t : t), e.slice(t, t + r)\n          },\n          where: function (e, t, r) {\n            return Je(e).filter((e) => {\n              const s = this.context.getFromScope(e, String(t).split(\".\"))\n              return void 0 === r ? E(s, this.context) : s === r\n            })\n          },\n          uniq: function (e) {\n            const t = {}\n            return (e || []).filter(\n              (e) => !t.hasOwnProperty(String(e)) && ((t[String(e)] = !0), !0)\n            )\n          },\n          date: function (e, t) {\n            let r = e\n            return (\n              \"now\" === e || \"today\" === e\n                ? (r = new Date())\n                : u(e)\n                ? (r = new Date(1e3 * e))\n                : a(e) &&\n                  (r = /^\\d+$/.test(e)\n                    ? new Date(1e3 * +e)\n                    : this.context.opts.preserveTimezones\n                    ? new Lt(e)\n                    : new Date(e)),\n              (function (e) {\n                return e instanceof Date && !isNaN(e.getTime())\n              })(r)\n                ? (function (e, t) {\n                    let r = e\n                    r instanceof Lt && (r = r.getDisplayDate())\n                    let s,\n                      n = \"\",\n                      i = t\n                    for (; (s = bt.exec(i)); )\n                      (n += i.slice(0, s.index)),\n                        (i = i.slice(s.index + s[0].length)),\n                        (n += Mt(r, s))\n                    return n + i\n                  })(r, t)\n                : e\n            )\n          },\n          Default: function (e, t) {\n            return f(e) || a(e) ? (e.length ? e : t) : R(c(e), this.context) ? t : e\n          },\n          json: function (e) {\n            return JSON.stringify(e)\n          },\n          append: function (e, t) {\n            return de(2 === arguments.length, () => \"append expect 2 arguments\"), h(e) + h(t)\n          },\n          prepend: function (e, t) {\n            return de(2 === arguments.length, () => \"prepend expect 2 arguments\"), h(t) + h(e)\n          },\n          lstrip: function (e) {\n            return h(e).replace(/^\\s+/, \"\")\n          },\n          downcase: function (e) {\n            return h(e).toLowerCase()\n          },\n          upcase: function (e) {\n            return h(e).toUpperCase()\n          },\n          remove: function (e, t) {\n            return h(e).split(String(t)).join(\"\")\n          },\n          removeFirst: function (e, t) {\n            return h(e).replace(String(t), \"\")\n          },\n          rstrip: function (e) {\n            return h(e).replace(/\\s+$/, \"\")\n          },\n          split: function (e, t) {\n            return h(e).split(String(t))\n          },\n          strip: function (e) {\n            return h(e).trim()\n          },\n          stripNewlines: function (e) {\n            return h(e).replace(/\\n/g, \"\")\n          },\n          capitalize: function (e) {\n            return (e = h(e)).charAt(0).toUpperCase() + e.slice(1).toLowerCase()\n          },\n          replace: function (e, t, r) {\n            return h(e).split(String(t)).join(r)\n          },\n          replaceFirst: function (e, t, r) {\n            return h(e).replace(String(t), r)\n          },\n          truncate: function (e, t = 50, r = \"...\") {\n            return (e = h(e)).length <= t ? e : e.substr(0, t - r.length) + r\n          },\n          truncatewords: function (e, t = 15, r = \"...\") {\n            const s = e.split(/\\s+/)\n            let n = s.slice(0, t).join(\" \")\n            return s.length >= t && (n += r), n\n          },\n        })\n        class Nt {\n          constructor() {\n            this.impls = {}\n          }\n          get(e) {\n            const t = this.impls[e]\n            return de(t, () => `tag \"${e}\" not found`), t\n          }\n          set(e, t) {\n            this.impls[e] = t\n          }\n        }\n        class $t {\n          constructor(e, t) {\n            ;(this.strictFilters = e), (this.liquid = t), (this.impls = {})\n          }\n          get(e) {\n            const t = this.impls[e]\n            return de(t || !this.strictFilters, () => `undefined filter: ${e}`), t\n          }\n          set(e, t) {\n            this.impls[e] = t\n          }\n          create(e, t) {\n            return new Me(e, this.get(e), t, this.liquid)\n          }\n        }\n        class Ct {\n          constructor(e = {}) {\n            var t\n            ;(this.options = ((t = L(e)), Object.assign({}, M, t))),\n              (this.parser = new ze(this)),\n              (this.renderer = new Re()),\n              (this.filters = new $t(this.options.strictFilters, this)),\n              (this.tags = new Nt()),\n              g(ut, (e, t) => this.registerTag(v(t), e)),\n              g(Pt, (e, t) => this.registerFilter(v(t), e))\n          }\n          parse(e, t) {\n            const r = new qe(e, this.options.operatorsTrie, t).readTopLevelTokens(this.options)\n            return this.parser.parse(r)\n          }\n          _render(e, t, r, s) {\n            const n = Object.assign({}, this.options, L(r)),\n              i = new z(t, n, s),\n              o = new Ee(n.keepOutputType)\n            return this.renderer.renderTemplates(e, i, o)\n          }\n          async render(e, t, r) {\n            return Ce(this._render(e, t, r, !1))\n          }\n          renderSync(e, t, r) {\n            return Ie(this._render(e, t, r, !0))\n          }\n          _parseAndRender(e, t, r, s) {\n            const n = this.parse(e)\n            return this._render(n, t, r, s)\n          }\n          async parseAndRender(e, t, r) {\n            return Ce(this._parseAndRender(e, t, r, !1))\n          }\n          parseAndRenderSync(e, t, r) {\n            return Ie(this._parseAndRender(e, t, r, !0))\n          }\n          *_parseFile(e, t, r) {\n            const s = Object.assign({}, this.options, L(t)),\n              n = s.root.map((t) => s.fs.resolve(t, e, s.extname))\n            if (void 0 !== s.fs.fallback) {\n              const t = s.fs.fallback(e)\n              void 0 !== t && n.push(t)\n            }\n            for (const e of n) {\n              const { cache: t } = s\n              if (t) {\n                const r = yield t.read(e)\n                if (r) return r\n              }\n              if (!(r ? s.fs.existsSync(e) : yield s.fs.exists(e))) continue\n              const n = this.parse(r ? s.fs.readFileSync(e) : yield s.fs.readFile(e), e)\n              return t && t.write(e, n), n\n            }\n            throw this.lookupError(e, s.root)\n          }\n          async parseFile(e, t) {\n            return Ce(this._parseFile(e, t, !1))\n          }\n          parseFileSync(e, t) {\n            return Ie(this._parseFile(e, t, !0))\n          }\n          async renderFile(e, t, r) {\n            const s = await this.parseFile(e, r)\n            return this.render(s, t, r)\n          }\n          renderFileSync(e, t, r) {\n            const s = this.parseFileSync(e, r)\n            return this.renderSync(s, t, r)\n          }\n          _evalValue(e, t) {\n            return new Le(e, this).value(t, !1)\n          }\n          async evalValue(e, t) {\n            return Ce(this._evalValue(e, t))\n          }\n          evalValueSync(e, t) {\n            return Ie(this._evalValue(e, t))\n          }\n          registerFilter(e, t) {\n            this.filters.set(e, t)\n          }\n          registerTag(e, t) {\n            this.tags.set(e, t)\n          }\n          plugin(e) {\n            return e.call(this, Ct)\n          }\n          express() {\n            const e = this\n            return function (t, r, s) {\n              const n = { root: [...P(this.root), ...e.options.root] }\n              e.renderFile(t, r, n).then((e) => s(null, e), s)\n            }\n          }\n          lookupError(e, t) {\n            const r = new Error(\"ENOENT\")\n            return (r.message = `ENOENT: Failed to lookup \"${e}\" in \"${t}\"`), (r.code = \"ENOENT\"), r\n          }\n          async getTemplate(e, t) {\n            return this.parseFile(e, t)\n          }\n          getTemplateSync(e, t) {\n            return this.parseFileSync(e, t)\n          }\n        }\n      },\n    },\n    __webpack_module_cache__ = {}\n  function __webpack_require__(e) {\n    var t = __webpack_module_cache__[e]\n    if (void 0 !== t) return t.exports\n    var r = (__webpack_module_cache__[e] = { exports: {} })\n    return __webpack_modules__[e](r, r.exports, __webpack_require__), r.exports\n  }\n  ;(__webpack_require__.d = (e, t) => {\n    for (var r in t)\n      __webpack_require__.o(t, r) &&\n        !__webpack_require__.o(e, r) &&\n        Object.defineProperty(e, r, { enumerable: !0, get: t[r] })\n  }),\n    (__webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),\n    (__webpack_require__.r = (e) => {\n      \"undefined\" != typeof Symbol &&\n        Symbol.toStringTag &&\n        Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }),\n        Object.defineProperty(e, \"__esModule\", { value: !0 })\n    })\n  var __webpack_exports__ = {}\n  ;(() => {\n    __webpack_require__.r(__webpack_exports__),\n      __webpack_require__.d(__webpack_exports__, {\n        evaluate64: () => evaluate64,\n        evaluate: () => evaluate,\n        evaluateJS: () => evaluateJS,\n        evaluateJS64: () => evaluateJS64,\n      })\n    var liquidjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(620),\n      js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(276),\n      engine = new liquidjs__WEBPACK_IMPORTED_MODULE_0__.Kj(),\n      evaluate64 = function (e) {\n        var t = js_base64__WEBPACK_IMPORTED_MODULE_1__.Jx(e),\n          r = JSON.parse(t)\n        return evaluate(r).toString()\n      },\n      evaluate = function (e) {\n        var t = e.expression,\n          r = e.values,\n          s = engine.parse(\"{% if \" + t + \" %}true{% else %}false{% endif %}\")\n        return \"true\" === engine.renderSync(s, r)\n      },\n      evaluateJS = function (_a) {\n        var expressionJS = _a.expressionJS,\n          values = _a.values\n        try {\n          var func = eval(expressionJS)\n          return !!func(values)\n        } catch (e) {\n          return console.error(\"e\", e), !1\n        }\n      },\n      evaluateJS64 = function (e) {\n        var t = js_base64__WEBPACK_IMPORTED_MODULE_1__.Jx(e),\n          r = JSON.parse(t)\n        return evaluateJS(r).toString()\n      }\n  })(),\n    (SuperwallSDKJS = __webpack_exports__)\n})()\n"

    invoke-virtual {v0, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;

    invoke-virtual {v0}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;

    move-result-object v0

    sput-object v0, Lcom/superwall/sdk/paywall/presentation/rule_logic/expression_evaluator/ScriptKt;->SDKJS:Ljava/lang/String;

    return-void
.end method

.method public static final getSDKJS()Ljava/lang/String;
    .locals 1

    sget-object v0, Lcom/superwall/sdk/paywall/presentation/rule_logic/expression_evaluator/ScriptKt;->SDKJS:Ljava/lang/String;

    return-object v0
.end method
