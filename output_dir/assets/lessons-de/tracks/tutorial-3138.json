{
  "tutorial": {
    "id": 3138,
    "version": 3,
    "type": "guidedProject",
    "isNew": true,
    "codeLanguage": "node",
    "title": "Pixelraster - Teil 1",
    "descriptionContent": "Erstelle eine kollaborative Zeichen-App, die es deinen Nutzern ermöglicht, kreativ zu sein. Im ersten Teil richtest du das anfängliche Back-End ein.",
    "shortDescriptionContent": "",
    "showInTrack": true,
    "iconBanner": "tutorial-3138-icon-banner.svg",
    "chapters": [
      {
        "id": 15457,
        "title": "Kapitel #1",
        "type": "practiceLevel3",
        "lessons": [
          {
            "title": "Lesson #1",
            "id": 135904,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "Willkommen zum **Pixel Grid** Projekt. Wir werden das Back-End und das Front-End für eine kollaborative Zeichen-App entwickeln, die es deinen Nutzern ermöglicht, kreativ zu sein. Das Back-End wird das 20 x 20-Pixel-Raster und die Farbe, die jedes Raster hat, speichern. Das Front-End wird die Back-End-API nutzen, um das Raster anzuzeigen und die Pixelwerte basierend auf der Benutzereingabe zu aktualisieren.\n\nWir beginnen mit der Einrichtung des Back-Ends mit einem Express-Server.\n\n1. Deklariere eine Variable `express` und require das `express` Modul.\n2. Deklariere eine Variable `app` und initialisiere sie, indem du die `express` Funktion aufrufst.\n3. Deklariere eine Variable `PORT` und weise ihr den Wert `3000` zu.\n4. Verwende die `listen` Funktion auf `app`, um die App auf dem von der `PORT` Variablen angegebenen Port lauschen zu lassen.\n5. Logge eine Nachricht in die Konsole innerhalb des Callbacks der `listen` Funktion, damit wir wissen, dass unser Server ordnungsgemäß läuft.",
              "preselectedFileIndex": 0,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "",
                  "solvedContent": "const express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});"
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "",
                  "solvedContent": null
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/",
                "body": null
              }
            }
          },
          {
            "title": "Lesson #2",
            "id": 135905,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "Wir werden die Zeichnungen unserer Benutzer in einer SQLite-Datenbank speichern. Zu diesem Zweck verwenden wir die `better-sqlite3` Bibliothek.\n\n1. Importiere in `database.js` das `better-sqlite3` Modul mit `require(\"better-sqlite3\")`. Weise das resultierende Objekt einer Konstanten namens `Database` zu.\n2. Erstelle eine neue SQLite-Datenbank namens `grid.db`, indem du `new Database(\"/tmp/grid.db\")` aufrufst. Speichere das Datenbankobjekt in einer Konstanten namens `db`.",
              "preselectedFileIndex": 1,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "const express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n",
                  "solvedContent": null
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "",
                  "solvedContent": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n"
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/",
                "body": null
              }
            }
          },
          {
            "title": "Lesson #3",
            "id": 135906,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "Sobald die Datenbank eingerichtet ist, erstellen wir eine `grid`-Tabelle, um Rasterdaten zu speichern. Jeder Eintrag in dieser Tabelle wird einen Pixel darstellen. Wir benötigen Spalten für die Koordinaten `x` und `y` sowie die Farbe, die der Pixel anzeigen soll.\n\n1. Verwende die Methode `db.exec`, um einen SQL-Befehl auszuführen.\n2. Füge als Argument der Methode `db.exec` einen SQL-Befehl hinzu, um eine `grid`-Tabelle mit den folgenden Spalten zu erstellen:\n   - `x`: int\n   - `y`: int\n   - `color`: text\n3. Um zu vermeiden, dass bei jedem Ausführen der Datei `database.js` immer mehr Pixel zur Datenbank hinzugefügt werden, ändere den SQL-Befehl so, dass die Tabelle nur erstellt wird, wenn sie nicht bereits existiert.",
              "preselectedFileIndex": 1,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "const express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n",
                  "solvedContent": null
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n",
                  "solvedContent": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n"
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/",
                "body": null
              }
            }
          },
          {
            "title": "Lesson #5",
            "id": 135908,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "Um die Datenbankverbindung in anderen Dateien verwenden zu können, müssen wir sie exportieren.\n\n1. Verwende `module.exports`, um `db` am Ende der Datei zu exportieren.",
              "preselectedFileIndex": 1,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "const express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n",
                  "solvedContent": null
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n",
                  "solvedContent": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n\nmodule.exports = db;\n"
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/",
                "body": null
              }
            }
          },
          {
            "title": "Lesson #6",
            "id": 135909,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "In unserer Express-App werden wir uns mit der SQLite-Datenbank über die Datei `database.js` verbinden.\n\n1. Importiere das `db` Modul, das du aus der Datenbankdatei exportiert hast, mit der `require` Anweisung in der App-Datei.",
              "preselectedFileIndex": 0,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "const express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n",
                  "solvedContent": "const express = require(\"express\");\nconst db = require(\"./database\");\nconst app = express();\nconst PORT = 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n"
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n\nmodule.exports = db;\n",
                  "solvedContent": null
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/",
                "body": null
              }
            }
          },
          {
            "title": "Lesson #4",
            "id": 135907,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "Wir können auf die Datenbank zugreifen, und die Gittertabelle ist bereit. Als Nächstes werden wir die Tabelle mit einigen Standard-Gitterpunkten als Anfangsdaten füllen. Natürlich müssen wir die Tabelle nur füllen, wenn sie noch leer ist.\n\n1. Um zu überprüfen, ob wir die Tabelle mit Anfangsdaten füllen sollten, verwende eine SQL-Anweisung, um die Anzahl der vorhandenen Zeilen in der Tabelle zu zählen und speichere den Rückgabewert in einer Konstante wie `rowCount`.\n2. Erstelle ein Gitter mit 400 Gitterpunkt-Objekten. Jedes Objekt sollte eine *x*- und eine *y*-Eigenschaft haben, die die Koordinaten darstellen, sowie eine *color*-Eigenschaft.\n   - Verwende zwei verschachtelte `for`-Schleifen, um ein Gitter aus 400 Objekten zu erstellen.\n   - Die äußere Schleife sollte die Zeilen darstellen (x-Werte von `0` bis `19`).\n   - Die innere Schleife sollte die Spalten darstellen (y-Werte von `0` bis `19`).\n   - Jedes Gitterobjekt sollte die Farbe \"white\" haben.\n   - Speichere alle diese Objekte in einem einzigen Array.\n3. Füge das Gitter in die Datenbank ein, wenn es noch keine Zeilen in der Gittertabelle gibt.\n   - Bereite eine `INSERT INTO`-Anweisung vor, wie `INSERT INTO grid (x, y, color) VALUES (?, ?, ?)`.\n   - Verwende `db.transaction`, um alle Einfügungen für bessere Leistung und Zuverlässigkeit zu gruppieren.\n   - Führe die definierte Transaktion aus und übergebe das Array der Gitterobjekte, um alle 400 Gitterpunkte in einem einzigen Vorgang in die Datenbank einzufügen.",
              "preselectedFileIndex": 1,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "const express = require(\"express\");\nconst db = require(\"./database\");\nconst app = express();\nconst PORT = 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n",
                  "solvedContent": null
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n\nmodule.exports = db;\n",
                  "solvedContent": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n\nconst rowCount = db.prepare(\"SELECT COUNT(*) AS count FROM grid\").get().count;\n\nif (rowCount === 0) {\n  const grid = [];\n  for (let x = 0; x < 20; x++) {\n    for (let y = 0; y < 20; y++) {\n      grid.push({ x, y, color: \"white\" });\n    }\n  }\n\n  const insertStatement = db.prepare(\n    `INSERT INTO grid (x, y, color) VALUES (?, ?, ?)`,\n  );\n  const insertTransaction = db.transaction((rows) => {\n    for (const row of rows) {\n      insertStatement.run(row.x, row.y, row.color);\n    }\n  });\n\n  insertTransaction(grid);\n}\n\nmodule.exports = db;\n"
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/",
                "body": null
              }
            }
          },
          {
            "title": "Lesson #7",
            "id": 135910,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "Als nächstes richten wir eine Route `\"/grid\"` ein, um die Grid-Daten per GET abzurufen, damit das Front-End auf die Daten aus der Datenbank zugreifen kann. Wir werden diesen Endpunkt verwenden, um alle Zeilen in unserer Grid-Tabelle abzurufen und sie als JSON-Antwort zu senden.\n\n1. Definiere einen neuen `\"/grid\"` Endpunkt.\n2. Schreibe innerhalb der Route einen SQL `SELECT` Befehl mit `db.prepare(\"SELECT ...\").all()`, um alle Grid-Zeilen abzurufen.\n3. Sende die abgerufenen Zeilen als JSON-Antwort mit einer Eigenschaft namens *grid* zurück. Stelle sicher, dass der Status auf `200` gesetzt ist.\n4. Verwende einen `try-catch` Block, um potenzielle Fehler zu behandeln. Wenn ein Fehler auftritt, setze den Status auf `500` und sende eine JSON-Antwort mit einer *message* Eigenschaft zurück, die dem Client mitteilt, dass es ein Problem gab.\n\nIm nächsten Teil des Projekts werden wir diesen Endpunkt verwenden, um das Grid anzuzeigen.",
              "preselectedFileIndex": 0,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "const express = require(\"express\");\nconst db = require(\"./database\");\nconst app = express();\nconst PORT = 3000;\n\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n",
                  "solvedContent": "const express = require(\"express\");\nconst db = require(\"./database\");\nconst app = express();\nconst PORT = 3000;\n\napp.get(\"/grid\", (req, res) => {\n  try {\n    const rows = db.prepare(\"SELECT * FROM grid\").all();\n    res.status(200).json({ grid: rows });\n  } catch (error) {\n    res.status(500).json({ message: \"Error fetching grid data\", error });\n  }\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n"
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n\nconst rowCount = db.prepare(\"SELECT COUNT(*) AS count FROM grid\").get().count;\n\nif (rowCount === 0) {\n  const grid = [];\n  for (let x = 0; x < 20; x++) {\n    for (let y = 0; y < 20; y++) {\n      grid.push({ x, y, color: \"white\" });\n    }\n  }\n\n  const insertStatement = db.prepare(\n    `INSERT INTO grid (x, y, color) VALUES (?, ?, ?)`,\n  );\n  const insertTransaction = db.transaction((rows) => {\n    for (const row of rows) {\n      insertStatement.run(row.x, row.y, row.color);\n    }\n  });\n\n  insertTransaction(grid);\n}\n\nmodule.exports = db;\n",
                  "solvedContent": null
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/grid",
                "body": null
              }
            }
          },
          {
            "title": "Lesson #7 - Copy",
            "id": 135937,
            "contentType": "executableFiles",
            "images": [],
            "executableContent": {
              "instructions": "Bevor wir zum Front-End übergehen können, müssen wir CORS erlauben, was für *Cross-Origin Resource Sharing* steht. CORS ist ein Mechanismus, der es einem Server ermöglicht, Anfragen von einer anderen Domain zu akzeptieren, während sichere Interaktionen zwischen Servern und Front-End-Clients von verschiedenen Ursprüngen gewährleistet werden. Wir benötigen CORS, da das Back-End auf einer anderen Domain als das Front-End gehostet wird, was Browser standardmäßig aus Sicherheitsgründen einschränken.\n\nDurch das Importieren des CORS-Pakets können wir CORS erlauben und Cross-Origin-Anfragen auf unserem Server aktivieren.\n\n1. Erfordere das `\"cors\"`-Paket und weise es einer Variablen namens `cors` zu.\n2. Lasse die App die importierte Middleware `cors` verwenden, indem du `app.use` aufrufst und die Funktion `cors()` als Parameter übergibst.",
              "preselectedFileIndex": 0,
              "hasVisualOutput": false,
              "files": [
                {
                  "name": "app.js",
                  "codeLanguage": "javascript",
                  "content": "const express = require(\"express\");\nconst db = require(\"./database\");\nconst app = express();\nconst PORT = 3000;\n\napp.get(\"/grid\", (req, res) => {\n  try {\n    const rows = db.prepare(\"SELECT * FROM grid\").all();\n    res.status(200).json({ grid: rows });\n  } catch (error) {\n    res.status(500).json({ message: \"Error fetching grid data\", error });\n  }\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n",
                  "solvedContent": "const express = require(\"express\");\nconst cors = require(\"cors\");\nconst db = require(\"./database\");\nconst app = express();\nconst PORT = 3000;\n\napp.use(cors());\n\napp.get(\"/grid\", (req, res) => {\n  try {\n    const rows = db.prepare(\"SELECT * FROM grid\").all();\n    res.status(200).json({ grid: rows });\n  } catch (error) {\n    res.status(500).json({ message: \"Error fetching grid data\", error });\n  }\n});\n\napp.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});\n"
                },
                {
                  "name": "database.js",
                  "codeLanguage": "javascript",
                  "content": "const Database = require(\"better-sqlite3\");\nconst db = new Database(\"/tmp/grid.db\");\n\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS grid (\n    x INT,\n    y INT,\n    color TEXT\n  )\n`);\n\nconst rowCount = db.prepare(\"SELECT COUNT(*) AS count FROM grid\").get().count;\n\nif (rowCount === 0) {\n  const grid = [];\n  for (let x = 0; x < 20; x++) {\n    for (let y = 0; y < 20; y++) {\n      grid.push({ x, y, color: \"white\" });\n    }\n  }\n\n  const insertStatement = db.prepare(\n    `INSERT INTO grid (x, y, color) VALUES (?, ?, ?)`,\n  );\n  const insertTransaction = db.transaction((rows) => {\n    for (const row of rows) {\n      insertStatement.run(row.x, row.y, row.color);\n    }\n  });\n\n  insertTransaction(grid);\n}\n\nmodule.exports = db;\n",
                  "solvedContent": null
                }
              ],
              "hints": [],
              "httpOptions": {
                "method": "GET",
                "path": "/grid",
                "body": null
              }
            }
          }
        ]
      }
    ]
  }
}